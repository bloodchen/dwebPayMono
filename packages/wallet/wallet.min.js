/* Version: 1.0.12 - October 21, 2022 10:59:15 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.WalletHost = factory());
})(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var nbpeer_min = {exports: {}};

	/* Version: 1.0.31 - October 18, 2022 14:45:09 */

	(function (module, exports) {
	(function (global, factory) {
	  module.exports = factory() ;
	})(commonjsGlobal, function () {

	  var isBrowser = isBrowser || new Function('try {return this===window;}catch(e){ return false;}');
	  var io, eccryptoJS, fetch;
	  const g_isBrowser = isBrowser();
	  const str2Array = strData => Uint8Array.from(Array.from(strData).map(letter => letter.charCodeAt(0)));
	  const fromHexString = hexString => Uint8Array.from(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
	  function decodeEnc(encObj) {
	    encObj.iv = eccryptoJS.arrayToBuffer(encObj.iv.data);
	    encObj.mac = eccryptoJS.arrayToBuffer(encObj.mac.data);
	    encObj.ciphertext = eccryptoJS.arrayToBuffer(encObj.ciphertext.data);
	    encObj.ephemPublicKey = eccryptoJS.arrayToBuffer(encObj.ephemPublicKey.data);
	  }
	  async function loadScript(url) {
	    return new Promise(resolve => {
	      var script = document.createElement('script');
	      script.type = 'text/javascript';
	      script.onload = function () {
	        resolve(true);
	      };
	      script.onerror = () => {
	        console.error('error loading' + url);
	        resolve(false);
	      };
	      script.src = url;
	      document.getElementsByTagName('head')[0].appendChild(script);
	    });
	  }
	  let log = console.log;
	  class nbpeer {
	    constructor() {
	      this.eventCB = {};
	      this.enKeys = {};
	      console.log('nbpeer: 1.0.31 - October 18, 2022 14:45:09');
	    }
	    async init() {
	      if (!this.inited) {
	        if (g_isBrowser) {
	          if (!window.io) {
	            await loadScript('https://cdn.socket.io/4.5.0/socket.io.min.js');
	            io = window.io;
	          }
	          if (!window.eccryptoJS) {
	            await loadScript('https://unpkg.com/eccrypto-js@5.4.0/dist/umd/index.min.js');
	            eccryptoJS = window.eccryptoJS;
	          }
	          fetch = window.fetch;
	        } else {
	          io = require("socket.io-client").io;
	          eccryptoJS = require("eccrypto-js");
	          fetch = require('cross-fetch');
	        }
	        this.inited = true;
	      }
	    }
	    getId() {
	      return this.id;
	    }
	    async getSocketUrl(nbNode) {
	      let res = await fetch(nbNode + "/api/nodeinfo");
	      if (res.ok) {
	        const info = await res.json();
	        const pUrl = new URL(nbNode);
	        let relaySocket = "ws://" + pUrl.hostname + ":" + (info.socketPort || 31415);
	        if (info.socketServer) {
	          relaySocket = "ws://" + info.socketServer + ":" + (info.socketPort || 31415);
	        }
	        return relaySocket;
	      }
	      return null;
	    }
	    async create(info) {
	      await this.init();
	      if (!info.debug) {
	        log = msg => {};
	      }
	      this.keypair = eccryptoJS.generateKeyPair();
	      let socketUrl = info.socketUrl;
	      if (!socketUrl) {
	        socketUrl = await this.getSocketUrl(info.nbNode);
	      }
	      if (!socketUrl) {
	        throw "Need socketUrl or nbNode";
	      }
	      const self = this;
	      return new Promise(resolve => {
	        const manager = new io.Manager(socketUrl, {
	          autoConnect: false
	        });
	        delete info.node;
	        if (!info.id) {
	          info.id = Date.now().toString(36);
	        }
	        self.id = info.id;
	        const socket = manager.socket("/nbpeer");
	        socket.auth = {
	          info
	        };
	        manager.open(err => {
	          if (err) {
	            return {
	              code: 0,
	              msg: err
	            };
	          }
	        });
	        socket.connect();
	        socket.on('connect', () => {
	          log('connected socket:', socket.id); // x8WIv7-mJelg7on_ALbx

	          self.id = info.id;
	          self.socket = socket;
	          resolve({
	            code: 0,
	            msg: "success",
	            id: self.id
	          });
	        });
	        socket.on('exchangeKey', (from_id, args, ret) => {
	          const key = JSON.parse(args)[0];
	          self.setEncryptKey(key, from_id);
	          ret(self.getKey());
	        });
	        socket.onAny(async (event, ...args) => {
	          log('nbpeer:got event:', event, ...args);
	          if (event === 'exchangeKey') return;
	          const from_id = args[0];
	          const encrypted = JSON.parse(args[1]);
	          decodeEnc(encrypted);
	          const deMsg = await eccryptoJS.decrypt(this.keypair.privateKey, encrypted);
	          const argv = JSON.parse(deMsg.toString());
	          self._fire(event, from_id, ...argv, args[2]);
	        });
	      });
	    }
	    async connectTo(desid) {
	      const key = await this.send(desid, 'exchangeKey', this.getKey());
	      this.setEncryptKey(key, desid);
	    }
	    getKey() {
	      return eccryptoJS.getPublicCompressed(this.keypair.privateKey).toString('hex');
	    }
	    setEncryptKey(enKey, desid) {
	      this.enKeys[desid] = eccryptoJS.decompress(fromHexString(enKey));
	    }
	    async _fire(name, ...args) {
	      const cb = this.eventCB[name];
	      const cb1 = this.eventCB['_any'];
	      const ret = cb ? await cb(...args) : cb1 ? await cb1(name, ...args) : null;
	      const retFn = args[args.length - 1];
	      if (typeof retFn == 'function') {
	        retFn(ret);
	      }
	      return ret;
	    }
	    on(name, cb) {
	      if (!this.eventCB) this.eventCB = {};
	      this.eventCB[name] = cb;
	    }
	    onElse(cb) {
	      this.eventCB['_any'] = cb;
	    }
	    offAll() {
	      this.eventCB = {};
	    }
	    isConnected() {
	      return this.socket && this.socket.connected;
	    }
	    async disconnect() {
	      this.socket && this.socket.disconnect();
	      this.socket = null;
	      this._fire('disconnected');
	    }
	    async send(des_id, event, ...args) {
	      return new Promise(resolve => {
	        log("send event:", event, des_id, ...args);
	        let strArgs = JSON.stringify(args);
	        if (this.enKeys[des_id]) {
	          strArgs = JSON.stringify(eccryptoJS.encryptSync(this.enKeys[des_id], str2Array(strArgs)));
	        }
	        this.socket.emit(event, des_id, this.id, strArgs, res => {
	          resolve(res);
	        });
	      });
	    }
	  }
	  return nbpeer;
	});
	}(nbpeer_min));

	var nbpeer = nbpeer_min.exports;

	var isBrowser = isBrowser || new Function('try {return this===window;}catch(e){ return false;}');
	const g_isBrowser = isBrowser();
	var fetch = typeof window === 'undefined' ? null : window.fetch;
	class WalletHost {
	  constructor() {
	    this.eventCB = {};
	    if (!g_isBrowser) {
	      fetch = require('cross-fetch');
	    }
	  }
	  async init({
	    appid
	  }) {
	    this.appid = appid;
	    this.approved = false;
	    this.id = Date.now().toString(36);
	    this.eventCB = {};
	    this.nbpeer = new nbpeer();
	    await this.nbpeer.init();
	    this.nbpeer.on("connectWallet", async para => {
	      return await this.connectApp(para);
	    });
	    this.nbpeer.onElse(async (eName, ...argv) => {
	      console.log("got nbpeer event:", eName, ...argv);
	      return await this._fire(eName, ...argv);
	    });
	  }
	  async connectApp(appInfo) {
	    this.desid = appInfo.id;
	    const ret = await this._fire('session_request', appInfo.id, {
	      name: 'pair_request',
	      para: [appInfo]
	    });
	    if (ret.code != 0) {
	      this.notify('rejected');
	      return ret;
	    }
	    this.notify('approved', {
	      permissons: appInfo.permissions,
	      wallet_id: this.id,
	      key: this.nbpeer.getKey()
	    });
	    this.permissions = appInfo.permissions;
	    this.approved = true;
	    return {
	      code: 0,
	      msg: "approved"
	    };
	  }
	  async pair(uri) {
	    if (this.nbpeer) {
	      this.disconnect();
	    }
	    const parseUrl = new URL(uri);
	    const url_id = parseUrl.pathname;
	    const nbNode = parseUrl.searchParams.get('node');
	    const path = parseUrl.searchParams.get('path');
	    if (nbNode) {
	      this.nbNode = nbNode;
	      const r = await this.nbpeer.create({
	        id: this.id,
	        nbNode: this.nbNode,
	        debug: true
	      });
	      await this.nbpeer.connectTo(url_id);
	      if (r.code != 0) {
	        return {
	          code: 1,
	          msg: "cannot connect to node:",
	          nbNode
	        };
	      }
	      const res = await fetch(nbNode + path);
	      if (!res.ok) {
	        return {
	          code: 1,
	          msg: "cannot fetch:" + nbNode + path
	        };
	      }
	      const appInfo = await res.json();
	      console.log(appInfo);
	      if (url_id != appInfo.id) {
	        return {
	          code: 1,
	          msg: "invalid id"
	        };
	      }
	      return await this.connectApp(appInfo);
	    }
	    return {
	      code: 1,
	      msg: "invalid format"
	    };
	  }
	  async getResult(...args) {
	    const func = args[0];
	    const para = args.slice(1);
	    const request = {
	      name: func,
	      para
	    };
	    const res = await this.nbpeer.send(this.desid, "session_request", request);
	    return res;
	  }
	  notify(name, para) {
	    this.desid && this.nbpeer.send(this.desid, 'session_notify', {
	      name,
	      para
	    });
	  }
	  on(eventName, cb) {
	    this.eventCB[eventName] = cb;
	  }
	  onElse(cb) {
	    this.eventCB['_any'] = cb;
	  }
	  async _fire(name, ...argv) {
	    const cb = this.eventCB[name];
	    const cb1 = this.eventCB['_any'];
	    const ret = cb ? await cb(...argv) : cb1 ? await cb1(name, ...argv) : null;
	    argv[argv.length - 1];
	    /*if (typeof retFn == 'function') {
	        retFn(ret)
	    }*/
	    return ret;
	  }
	  async disconnect() {
	    this.nbpeer.disconnect();
	  }
	}

	return WalletHost;

}));
