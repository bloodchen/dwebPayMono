/* Version: 1.0.0 - October 7, 2022 17:54:17 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.WalletHost = factory());
})(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var nbpeer_min = {exports: {}};

	/* Version: 1.0.22 - September 23, 2022 15:44:05 */

	(function (module, exports) {
	(function (global, factory) {
	  module.exports = factory() ;
	})(commonjsGlobal, function () {

	  var isBrowser = isBrowser || new Function('try {return this===window;}catch(e){ return false;}');
	  isBrowser();

	  const str2Array = strData => Uint8Array.from(Array.from(strData).map(letter => letter.charCodeAt(0)));

	  const fromHexString = hexString => Uint8Array.from(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));

	  function decodeEnc(encObj) {
	    encObj.iv = eccryptoJS.arrayToBuffer(encObj.iv.data);
	    encObj.mac = eccryptoJS.arrayToBuffer(encObj.mac.data);
	    encObj.ciphertext = eccryptoJS.arrayToBuffer(encObj.ciphertext.data);
	    encObj.ephemPublicKey = eccryptoJS.arrayToBuffer(encObj.ephemPublicKey.data);
	  }

	  async function loadScript(url) {
	    return new Promise(resolve => {
	      var script = document.createElement('script');
	      script.type = 'text/javascript';

	      script.onload = function () {
	        resolve(true);
	      };

	      script.onerror = () => {
	        console.error('error loading' + url);
	        resolve(false);
	      };

	      script.src = url;
	      document.getElementsByTagName('head')[0].appendChild(script);
	    });
	  }

	  let log = console.log;

	  class nbpeer {
	    constructor() {
	      this.eventCB = {};
	      console.log('nbpeer: 1.0.22 - September 23, 2022 15:44:05');
	    }

	    async init() {
	      if (!this.inited) {
	        if (!window.io) {
	          await loadScript('https://cdn.socket.io/4.5.0/socket.io.min.js');
	        }

	        if (!window.eccryptoJS) {
	          await loadScript('https://unpkg.com/eccrypto-js@5.4.0/dist/umd/index.min.js');
	          this.keypair = eccryptoJS.generateKeyPair();
	        }

	        this.inited = true;
	      }
	    }

	    async create(info) {
	      await this.init();

	      if (!info.debug) {
	        log = msg => {};
	      }

	      const self = this;
	      return new Promise(resolve => {
	        //const socket = io(info.node,{autoConnect:false});
	        const manager = new io.Manager(info.node, {
	          autoConnect: false
	        });
	        delete info.node;

	        if (!info.id) {
	          info.id = Date.now().toString(36);
	        }

	        const socket = manager.socket("/nbpeer");
	        socket.auth = {
	          info
	        };
	        manager.open(err => {
	          if (err) {
	            return {
	              code: 0,
	              msg: err
	            };
	          }
	        });
	        socket.connect();
	        socket.on('connect', () => {
	          log('connected socket:', socket.id); // x8WIv7-mJelg7on_ALbx

	          self.id = info.id;
	          self.socket = socket;
	          resolve({
	            code: 0,
	            msg: "success",
	            id: self.id
	          });
	        });
	        socket.onAny(async (event, ...args) => {
	          log('nbpeer:got event:', event, ...args);
	          const encrypted = JSON.parse(args[0]);
	          decodeEnc(encrypted);
	          const deMsg = await eccryptoJS.decrypt(this.keypair.privateKey, encrypted);
	          const argv = JSON.parse(deMsg.toString());

	          self._fire(event, ...argv, args[1]);
	        });
	      });
	    }

	    getKey() {
	      return eccryptoJS.getPublicCompressed(this.keypair.privateKey).toString('hex');
	    }

	    setEncryptKey(enKey) {
	      this.enKey = eccryptoJS.decompress(fromHexString(enKey));
	    }

	    async _fire(name, ...args) {
	      const cb = this.eventCB[name];
	      const cb1 = this.eventCB['_any'];
	      const ret = cb ? await cb(...args) : cb1 ? await cb1(name, ...args) : null;
	      const retFn = args[args.length - 1];

	      if (typeof retFn == 'function') {
	        retFn(ret);
	      }

	      return ret;
	    }

	    on(name, cb) {
	      if (!this.eventCB) this.eventCB = {};
	      this.eventCB[name] = cb;
	    }

	    onElse(cb) {
	      this.eventCB['_any'] = cb;
	    }

	    offAll() {
	      this.eventCB = {};
	    }

	    isConnected() {
	      return this.socket && this.socket.connected;
	    }

	    async disconnect() {
	      this.socket && this.socket.disconnect();
	      this.socket = null;

	      this._fire('disconnected');
	    }

	    async send(des_id, event, ...args) {
	      return new Promise(resolve => {
	        console.log("send event:", event, des_id, ...args);
	        let strArgs = JSON.stringify(args);

	        if (this.enKey) {
	          strArgs = JSON.stringify(eccryptoJS.encryptSync(this.enKey, str2Array(strArgs)));
	        }

	        this.socket.emit(event, des_id, strArgs, res => {
	          resolve(res);
	        });
	      });
	    }

	  }

	  return nbpeer;
	});
	}(nbpeer_min));

	var nbpeer = nbpeer_min.exports;

	var isBrowser = isBrowser || new Function('try {return this===window;}catch(e){ return false;}');
	const g_isBrowser = isBrowser();
	class WalletHost {
	  constructor() {
	    this.eventCB = {};
	  }

	  async init({
	    appid
	  }) {
	    this.appid = appid;
	    this.approved = false;
	    this.id = Date.now().toString(36);
	    this.eventCB = {};
	    this.nbpeer = new nbpeer();
	    await this.nbpeer.init();
	    this.nbpeer.on("connectWallet", async para => {
	      return await this.connectApp(para);
	    });
	    this.nbpeer.onElse((eName, ...argv) => {
	      console.log("got nbpeer event:", eName, ...argv);

	      this._fire(eName, ...argv);
	    });
	  }

	  async connectApp(appInfo) {
	    this.desid = appInfo.id;
	    const ret = await this._fire('session_request', {
	      name: 'pair_request',
	      para: [appInfo]
	    });

	    if (ret.code != 0) {
	      this.notify('rejected');
	      return ret;
	    }

	    this.notify('approved', {
	      permissons: appInfo.permissions,
	      wallet_id: this.id,
	      key: this.nbpeer.getKey()
	    });
	    this.permissions = appInfo.permissions;
	    this.approved = true;
	    return {
	      code: 0,
	      msg: "approved"
	    };
	  }

	  async pair(uri) {
	    if (this.nbpeer) {
	      this.disconnect();
	    }

	    const parseUrl = new URL(uri);
	    const url_id = parseUrl.pathname;
	    const nbNode = parseUrl.searchParams.get('node');
	    const path = parseUrl.searchParams.get('path');
	    const key = parseUrl.searchParams.get('key');

	    if (nbNode) {
	      this.nbNode = nbNode;
	      await this.updateNode();
	      const r = await this.nbpeer.create({
	        id: this.id,
	        node: this.relaySocket,
	        debug: true
	      });
	      this.nbpeer.setEncryptKey(key);

	      if (r.code != 0) {
	        return {
	          code: 1,
	          msg: "cannot connect to node:",
	          nbNode
	        };
	      }

	      const res = await fetch(nbNode + path);

	      if (!res.ok) {
	        return {
	          code: 1,
	          msg: "cannot fetch:" + nbNode + path
	        };
	      }

	      const appInfo = await res.json();
	      console.log(appInfo);

	      if (url_id != appInfo.id) {
	        return {
	          code: 1,
	          msg: "invalid id"
	        };
	      }

	      return await this.connectApp(appInfo);
	    }

	    return {
	      code: 1,
	      msg: "invalid format"
	    };
	  }

	  async getResult(...args) {
	    const func = args[0];
	    const para = args.slice(1);
	    const request = {
	      name: func,
	      para
	    };
	    const res = await this.nbpeer.send(this.desid, "session_request", request);
	    return res;
	  }

	  notify(name, para) {
	    this.desid && this.nbpeer.send(this.desid, 'session_event', {
	      name,
	      para
	    });
	  }

	  on(eventName, cb) {
	    this.eventCB[eventName] = cb;
	  }

	  onElse(cb) {
	    this.eventCB['_any'] = cb;
	  }

	  async _fire(name, ...argv) {
	    const cb = this.eventCB[name];
	    const cb1 = this.eventCB['_any'];
	    const ret = cb ? await cb(...argv) : cb1 ? await cb1(name, ...argv) : null;
	    const retFn = argv[argv.length - 1];

	    if (typeof retFn == 'function') {
	      retFn(ret);
	    }

	    return ret;
	  }

	  async updateNode(nbNode) {
	    if (!nbNode) nbNode = this.nbNode;
	    let res = await fetch(nbNode + "/api/nodeinfo");

	    if (res.ok) {
	      const info = await res.json();
	      const pUrl = g_isBrowser ? new URL(nbNode) : URL.parse(url);
	      this.relaySocket = "ws://" + pUrl.hostname + ":" + (info.socketPort || 31415);

	      if (info.socketServer) {
	        relaySocket = "ws://" + info.socketServer + ":" + (info.socketPort || 31415);
	      }

	      this.nbNode = nbNode;
	      return true;
	    }

	    return false;
	  }

	  async disconnect() {
	    this.nbpeer.disconnect();
	  }

	}

	return WalletHost;

}));
