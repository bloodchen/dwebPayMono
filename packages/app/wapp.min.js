/* Version: 1.0.17 - October 31, 2022 13:59:05 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.WalletApp = factory());
})(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var qrmodal_min = {exports: {}};

	/* Version: 1.0.2 - October 28, 2022 08:45:23 */

	(function (module, exports) {
	(function (global, factory) {
	  module.exports = factory() ;
	})(commonjsGlobal, function () {

	  class Util {
	    static async loadScript(url) {
	      return new Promise(resolve => {
	        var script = document.createElement("script");
	        script.type = "text/javascript";
	        script.onload = function () {
	          resolve(true);
	        };
	        script.onerror = () => {
	          console.error("error loading" + url);
	          resolve(false);
	        };
	        script.src = url;
	        document.getElementsByTagName("head")[0].appendChild(script);
	      });
	    }
	  }
	  const payPopupHtml = `
<style scoped>
._opay_pageOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0.5;
  background: #000;
  z-index: 1000;
}

#_opay_payPopup {
  display:flex;
  position:absolute;
  align-items: center;
  left: 50%; 
  top: 50%; 
  transform: translate(-50%, -50%);
  width: 30rem;
  z-index: 1100;
}
._opay_closeButton {
    margin: 5px;
    cursor: pointer;
    float: right;
  }

._qrcode{
  box-shadow: 0 4px 12px 0 rgb(37 41 46 / 25%);
  width:300px;
  height:300px;
  margin:20px auto;
  display:block;
}
._wallet{
  width:140px;
  height:180px;
  margin:50px auto;
}
._wallet ._icon{
  margin:5px 3px;
  width:96px;
  height:96px;
  box-shadow: 0 4px 12px 0 rgb(37 41 46 / 25%);
}
._subTitle{
  color: rgba(60, 66, 82, 0.6);
    font-size: 16px;
    font-weight: 600;
    letter-spacing: 0;
    line-height: 1.1875em;
    margin: 10px 0 20px 0;
    text-align: center;
    width: 100%;
}
._tabs {
  width: 100%;
  text-align:center;
  background-color: white;
  border-radius: 0.5rem;
  box-shadow: 0 5px 10px rgba(0, 0, 0, 0.25);
}

._tab-control {
  display: inline-block;
  text-align:center;
  border-bottom: 2px solid transparent;
  font-size: 1.25rem;
  padding: 0.6rem 2rem;
  cursor: pointer;
  transition: all 0.25s ease;
}

._tab-control:hover {
  color: #ed1e79;
}

._tab-content {
  border-top: 1px solid #ed1e79;
  padding: 1rem;
}

._tab-panel {
  display: none;
  height:400px;
}

/* Magic style */
input[type="radio"]:checked + ._tab-control {
  font-weight: 600;
  color: #ed1e79;
  border-bottom-color: #ed1e79;
}

#_tab-1:checked ~ ._tab-content > #_tab-panel-1 {
  display: block;
}

#_tab-2:checked ~ ._tab-content > #_tab-panel-2 {
  display: block;
}
</style>
<div id="_opay_payPopup">

  <div class="_tabs">
    <div class="_opay_closeButton">
        ✖
      </div>
    <input hidden type="radio" name="tab-css" id="_tab-1" checked />
    <label class="_tab-control" for="_tab-1" tid="qrPay">QR Code</label>
    <input hidden type="radio" name="tab-css" id="_tab-2" />
    <label class="_tab-control" for="_tab-2" tid="desktop">Desktop</label>
  
    <div class="_tab-content">
      <div id="_tab-panel-1" class="_tab-panel">
        <p id="_debug" style="color:red;">DEBUG (not for production)</p>
        <div class="_subTitle" tid="title_qr_panel">Scan QR code with an dwebPay compatible wallet 
        </div>
        <img id="_opay_qrcode" class="_qrcode"></img>
        <a href="#" id="_copy_clipboard" tid="_copy_clipboard">Copy to Clipboard</a><span id='_check_success' style="display:none;">✌</span>
      </div>
      <div id="_tab-panel-2" class="_tab-panel">
        <div class="_subTitle" tid="title_desktop_panel">
          Choose your prefered Wallet
        </div>
        <div class="_wallet">
        <img id="_vboxWallet" src="$scriptPath$vbox-icon.png" class="_icon"/><p>VBox</p></div>
      </div>
      
    </div>
  </div>
</div>
`;
	  let scriptPath = "";
	  try {
	    scriptPath = document.currentScript.src;
	  } catch (e) {}
	  class qrModal {
	    constructor({
	      bridge,
	      debug
	    }) {
	      this.nbNode = bridge;
	      this.debug = debug;
	    }
	    async show(uri, callback) {
	      const self = this;
	      this.abortController = new AbortController();
	      let emPopup = document.querySelector("#_opay_payPopup");
	      if (!emPopup) {
	        let src = scriptPath;
	        src = src.slice(0, src.lastIndexOf('/') + 1);
	        const html = payPopupHtml.replace("$scriptPath$", src);
	        emPopup = document.createElement('div');
	        emPopup.innerHTML = html;
	        document.body.appendChild(emPopup);
	        emPopup = document.querySelector("#_opay_payPopup");
	      } else {
	        emPopup.style.display = 'flex';
	      }
	      let emOverlay = document.querySelector("._opay_pageOverlay");
	      if (!emOverlay) document.querySelector("body").insertAdjacentHTML('beforeend', '<div class="_opay_pageOverlay"></div>');else {
	        emOverlay.style.display = 'block';
	      }
	      self.translate("_opay_payPopup");
	      await self.genQRImg(uri, "_opay_qrcode");
	      if (!self.debug) {
	        document.querySelector("#_debug").style.display = 'none';
	      } //vbox button

	      this.onEvent('click', "#_vboxWallet", () => {
	        callback("clickWallet", "vbox");
	      }); // Close button

	      this.onEvent('click', "._opay_closeButton", () => {
	        console.log('click close');
	        this.closePopup();
	        callback("closed");
	      });
	      this.onEvent('click', "#_copy_clipboard", () => {
	        navigator.clipboard.writeText(uri).then(() => {
	          document.querySelector('#_check_success').style.display = 'inline';
	          setTimeout(() => {
	            document.querySelector('#_check_success').style.display = 'none';
	          }, 3000);
	        });
	      });
	      this.callback = callback;
	    }
	    onEvent(eventType, selector, callback) {
	      const elm = document.querySelector(selector);
	      if (elm) {
	        elm.addEventListener(eventType, callback, {
	          signal: this.abortController.signal
	        });
	      }
	    }
	    closePopup() {
	      document.querySelector('#_opay_payPopup').style.display = 'none'; // hide

	      document.querySelector('._opay_pageOverlay').style.display = 'none'; // hide

	      if (this.callback) {
	        this.abortController.abort();
	      }
	    }
	    close() {
	      this.closePopup();
	    }
	    translate(parentID) {
	      if (navigator.language.toLowerCase() != "zh-cn") return;
	      var cntext = {
	        webPay: "网页",
	        qrPay: "扫码支付",
	        desktop: "桌面",
	        vbox: "傲游 VBox",
	        dot: "打点钱包",
	        title: "点击钱包或扫码",
	        vinstall: "未检测到，点击安装",
	        login: "登录",
	        next: "下一步",
	        title_qr_panel: "请使用 dwebPay 兼容钱包扫描",
	        title_desktop_panel: "请点击钱包",
	        _copy_clipboard: "复制到剪贴板"
	      };
	      var items = document.getElementById(parentID).querySelectorAll("[tid]");
	      for (let i = 0; i < items.length; i++) {
	        const item = items[i];
	        const tid = item.attributes['tid'].value;
	        item.innerText = cntext[tid];
	      }
	    }
	    async genQRImg(uri, imgID, checker = true) {
	      if (!window.qrcode) {
	        await Util.loadScript("https://cdnjs.cloudflare.com/ajax/libs/qrcode-generator/1.4.4/qrcode.min.js");
	      }
	      const strQR = uri;
	      var typeNumber = 0;
	      var errorCorrectionLevel = "L";
	      var qr = qrcode(typeNumber, errorCorrectionLevel);
	      qr.addData(strQR);
	      qr.make();
	      let strImgTag = qr.createDataURL(4);
	      document.getElementById(imgID).src = strImgTag;
	    }
	  }
	  return qrModal;
	});
	}(qrmodal_min));

	var qrModal = qrmodal_min.exports;

	var nbpeer_min = {exports: {}};

	var localStorage$1 = {exports: {}};

	// http://www.rajdeepd.com/articles/chrome/localstrg/LocalStorageSample.htm

	// NOTE:
	// this varies from actual localStorage in some subtle ways

	// also, there is no persistence
	// TODO persist
	(function () {

	  var db;
	  function LocalStorage() {}
	  db = LocalStorage;
	  db.prototype.getItem = function (key) {
	    if (this.hasOwnProperty(key)) {
	      return String(this[key]);
	    }
	    return null;
	  };
	  db.prototype.setItem = function (key, val) {
	    this[key] = String(val);
	  };
	  db.prototype.removeItem = function (key) {
	    delete this[key];
	  };
	  db.prototype.clear = function () {
	    var self = this;
	    Object.keys(self).forEach(function (key) {
	      self[key] = undefined;
	      delete self[key];
	    });
	  };
	  db.prototype.key = function (i) {
	    i = i || 0;
	    return Object.keys(this)[i];
	  };
	  db.prototype.__defineGetter__('length', function () {
	    return Object.keys(this).length;
	  });
	  if (commonjsGlobal.localStorage) {
	    localStorage$1.exports = localStorage;
	  } else {
	    localStorage$1.exports = new LocalStorage();
	  }
	})();

	/* Version: 1.0.45 - October 31, 2022 13:55:45 */

	(function (module, exports) {
	(function (global, factory) {
	  module.exports = factory() ;
	})(commonjsGlobal, function () {

	  var isBrowser = isBrowser || new Function('try {return this===window;}catch(e){ return false;}');
	  var io, eccryptoJS;
	  const g_isBrowser = isBrowser();
	  const str2Array = strData => Uint8Array.from(Array.from(strData).map(letter => letter.charCodeAt(0)));
	  const fromHexString = hexString => Uint8Array.from(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
	  function decodeEnc(encObj) {
	    try {
	      encObj.iv = eccryptoJS.arrayToBuffer(encObj.iv.data);
	      encObj.mac = eccryptoJS.arrayToBuffer(encObj.mac.data);
	      encObj.ciphertext = eccryptoJS.arrayToBuffer(encObj.ciphertext.data);
	      encObj.ephemPublicKey = eccryptoJS.arrayToBuffer(encObj.ephemPublicKey.data);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	  async function loadScript(url) {
	    return new Promise(resolve => {
	      var script = document.createElement('script');
	      script.type = 'text/javascript';
	      script.onload = function () {
	        resolve(true);
	      };
	      script.onerror = () => {
	        console.error('error loading' + url);
	        resolve(false);
	      };
	      script.src = url;
	      document.getElementsByTagName('head')[0].appendChild(script);
	    });
	  }
	  let log = console.log;
	  class nbpeer {
	    constructor() {
	      this.eventCB = {};
	      this.enKeys = {};
	      console.log('nbpeer: 1.0.45 - October 31, 2022 13:55:45');
	    }
	    async init() {
	      if (!this.inited) {
	        if (g_isBrowser) {
	          if (!window.io) {
	            await loadScript('https://cdn.socket.io/4.5.0/socket.io.min.js');
	            io = window.io;
	          }
	          if (!window.eccryptoJS) {
	            await loadScript('https://unpkg.com/eccrypto-js@5.4.0/dist/umd/index.min.js');
	            eccryptoJS = window.eccryptoJS;
	          }
	        } else {
	          io = require("socket.io-client").io;
	          eccryptoJS = require("eccrypto-js");
	          require('cross-fetch');
	          commonjsGlobal.localStorage = localStorage$1.exports;
	        }
	        this.inited = true;
	      }
	    }
	    getId() {
	      return this.id;
	    }
	    async getSocketUrl(nbNode) {
	      /*let res = await fetch(nbNode + "/api/nodeinfo")
	      if (res.ok) {
	          const info = await res.json()
	          const pUrl = new URL(nbNode)
	          let relaySocket = "ws://" + pUrl.hostname + ":" + (info.socketPort || 31415)
	          if (info.socketServer) {
	              relaySocket = "ws://" + info.socketServer + ":" + (info.socketPort || 31415)
	          }
	          return relaySocket
	      }
	      return null*/
	      return nbNode;
	    }
	    async create(info) {
	      await this.init();
	      if (!info.debug) {
	        log = msg => {};
	      }
	      this.keypair = eccryptoJS.generateKeyPair();
	      let socketUrl = info.socketUrl;
	      if (!socketUrl) {
	        socketUrl = await this.getSocketUrl(info.nbNode);
	      }
	      if (!socketUrl) {
	        throw "Need socketUrl or nbNode";
	      }
	      const self = this;
	      return new Promise(resolve => {
	        const manager = new io.Manager(socketUrl, {
	          autoConnect: false
	        });
	        delete info.node;
	        if (!info.id) {
	          info.id = Date.now().toString(36);
	        }
	        self.id = info.id;
	        const socket = manager.socket("/nbpeer");
	        socket.auth = {
	          info
	        };
	        manager.open(err => {
	          if (err) {
	            return {
	              code: 1,
	              msg: err
	            };
	          }
	        });
	        socket.connect();
	        socket.on('connect', () => {
	          log('connected socket:', socket.id); // x8WIv7-mJelg7on_ALbx

	          self.id = info.id;
	          self.socket = socket;
	          self.restoreEnkeys();
	          self._fire("bridgeConnected", self.id);
	          resolve({
	            code: 0,
	            msg: "success",
	            id: self.id
	          });
	        });
	        socket.on('disconnect', function () {
	          self._fire("bridgeDisconnected", self.id);
	        });
	        socket.on('exchangeKey', (from_id, args, ret) => {
	          const key = JSON.parse(args)[0];
	          self.setEncryptKey(key, from_id);
	          ret(self.getKey());
	        });
	        socket.onAny(async (event, ...args) => {
	          log('nbpeer:got event:', event, ...args);
	          if (event === 'exchangeKey') return;
	          const from_id = args[0];
	          const encrypted = JSON.parse(args[1]);
	          if (!decodeEnc(encrypted)) {
	            const retFn = args[args.length - 1];
	            if (typeof retFn == 'function') {
	              retFn({
	                code: 1,
	                msg: "msg decode error"
	              });
	            }
	            console.error("msg decode error");
	            return;
	          }
	          const deMsg = await eccryptoJS.decrypt(this.keypair.privateKey, encrypted);
	          const argv = JSON.parse(deMsg.toString());
	          self._fire(event, from_id, ...argv, args[2]);
	        });
	      });
	    }
	    async restoreEnkeys() {
	      const res = localStorage.getItem("id_key_map");
	      if (!res) return false;
	      try {
	        const idKeyMap = JSON.parse(res);
	        for (const id in idKeyMap) {
	          const enKey = idKeyMap[id + '_hex'];
	          enKey && this.setEncryptKey(enKey, id, false);
	        }
	        return true;
	      } catch (e) {
	        console.error(e);
	        return false;
	      }
	    }
	    async connectTo(desid) {
	      if (this.enKeys[desid]) return this.enKeys[desid];
	      const key = await this.send(desid, 'exchangeKey', this.getKey());
	      if (key.code === 1000) return key;
	      this.setEncryptKey(key, desid);
	      return key;
	    }
	    getKey() {
	      return eccryptoJS.getPublicCompressed(this.keypair.privateKey).toString('hex');
	    }
	    setEncryptKey(enKey, desid, save = true) {
	      this.enKeys[desid] = eccryptoJS.decompress(fromHexString(enKey));
	      this.enKeys[desid + '_hex'] = enKey;
	      if (save) localStorage.setItem("id_key_map", JSON.stringify(this.enKeys));
	    }
	    async _fire(name, ...args) {
	      const cb = this.eventCB[name];
	      const cb1 = this.eventCB['_any'];
	      const ret = cb ? await cb(...args) : cb1 ? await cb1(name, ...args) : null;
	      const retFn = args[args.length - 1];
	      if (typeof retFn == 'function') {
	        retFn(ret);
	      }
	      return ret;
	    }
	    on(name, cb) {
	      if (!this.eventCB) this.eventCB = {};
	      this.eventCB[name] = cb;
	    }
	    onElse(cb) {
	      this.eventCB['_any'] = cb;
	    }
	    offAll() {
	      this.eventCB = {};
	    }
	    isConnected() {
	      return this.socket && this.socket.connected;
	    }
	    async disconnect() {
	      this.socket && this.socket.disconnect();
	      this.socket = null;
	      localStorage.setItem("id_key_map", null);
	      this.enKeys = {};
	      this._fire('disconnected');
	    }
	    async send(des_id, event, ...args) {
	      return new Promise(resolve => {
	        log("send event:", event, des_id, ...args);
	        let strArgs = JSON.stringify(args);
	        if (this.enKeys[des_id]) {
	          strArgs = JSON.stringify(eccryptoJS.encryptSync(this.enKeys[des_id], str2Array(strArgs)));
	        }
	        this.socket.emit(event, des_id, this.id, strArgs, res => {
	          resolve(res);
	        });
	      });
	    }
	  }
	  return nbpeer;
	});
	}(nbpeer_min));

	var nbpeer = nbpeer_min.exports;

	var isBrowser = isBrowser || new Function('try {return this===window;}catch(e){ return false;}');
	const g_isBrowser = isBrowser();
	var qrTermila;
	class WalletApp {
	  constructor() {
	    this.lastChecking = 0;
	  }
	  async init({
	    appid,
	    bridge,
	    debug = true
	  }) {
	    this.appid = appid;
	    this.nbNode = bridge;
	    this.debug = debug;
	    this.eventCB = {};
	    this.id = Date.now().toString(36);
	    if (!g_isBrowser) {
	      global.fetch = require("cross-fetch");
	      qrTermila = require('qrcode-terminal');
	    }
	    const res = await fetch(bridge + "/api/q/" + appid);
	    if (res.ok) {
	      this.meta = await res.json();
	    } else {
	      console.error("can't fetch:", appid, "from:", bridge);
	      return false;
	    }
	    if (this.meta.allowSite && !debug) ;
	    this.walletId = localStorage.getItem("walletId");
	    this.nbpeer = new nbpeer();
	    await this.nbpeer.init();
	    this.modal = new qrModal({
	      bridge,
	      debug
	    });

	    //this.nbpeer.on('bridgeConnected', async () => {
	    //    console.log('isConnected:', await this.isConnected({}))
	    //})
	    this.nbpeer.onElse((eName, ...args) => {
	      console.log("got nbpeer event:", eName, ...args);
	      this._fire(eName, ...args);
	    });
	    return true;
	  }
	  async connect({
	    walletId,
	    permissions
	  }) {
	    const self = this;
	    return new Promise(async resolve => {
	      const options = {
	        id: this.id,
	        appid: this.appid,
	        permissions
	      };
	      let res = await this.createSession();
	      if (res.code == 0) {
	        this.nbpeer.on('session_notify', (wallet_id, event) => {
	          if (event.name === 'approved') {
	            self.walletId = wallet_id;
	            console.log('got wallet id:', wallet_id);
	            localStorage.setItem("walletId", wallet_id);
	            self.modal.close();
	            resolve({
	              code: 0,
	              wallet_id,
	              msg: "approved"
	            });
	            return;
	          }
	          self._fire('session_notify', wallet_id, event);
	        });
	        if (await this.isConnected({
	          walletId
	        })) {
	          resolve({
	            code: 0,
	            msg: "connected"
	          });
	          return;
	        }
	        const url = await this.optionsToUrl(options);
	        const uri = `wp:${this.id}?node=${encodeURIComponent(this.nbNode)}&cmd=connect&key=${this.nbpeer.getKey()}&path=${encodeURIComponent(url)}`;
	        console.log(uri);
	        if (g_isBrowser) {
	          this.modal.show(uri, async (event, para) => {
	            console.log("event from modal:", event, para);
	            if (event === 'closed') {
	              resolve({
	                code: 1,
	                msg: "Cancelled"
	              });
	              return;
	            }
	            if (event === 'clickWallet' && para === 'vbox') {
	              if (!window.VBox) {
	                resolve({
	                  code: 1,
	                  msg: "VBox is not found"
	                });
	                return;
	              }
	              window.VBox.connect(uri);
	            }
	          });
	        } else {
	          //node envirment, show terminal qrcode
	          qrTermila.generate(uri, {
	            small: true
	          });
	        }
	      }
	    });
	  }
	  async getBalance({
	    walletId,
	    address,
	    chain
	  }) {
	    return await this.getResult(walletId, 'getBalance', {
	      address,
	      chain
	    });
	  }
	  async getPubKey({
	    walletId,
	    address,
	    chain
	  }) {
	    return await this.getResult(walletId, 'getPubKey', {
	      address,
	      chain
	    });
	  }
	  async signTransaction({
	    walletId,
	    options
	  }) {
	    return await this.getResult(walletId, 'signTransaction', {
	      options
	    });
	  }
	  async sendTransaction({
	    walletId,
	    options
	  }) {
	    return await this.getResult(walletId, 'sendTransaction', {
	      options
	    });
	  }
	  async getAddresses({
	    walletId,
	    chain
	  }) {
	    return await this.getResult(walletId, 'getAddresses', {
	      chain
	    });
	  }
	  async getAccounts({
	    walletId,
	    chain
	  }) {
	    return await this.getResult(walletId, 'getAccounts', {
	      chain
	    });
	  }
	  async signMessage({
	    walletId,
	    message,
	    address,
	    chain
	  }) {
	    return await this.getResult(walletId, 'signMessage', {
	      message,
	      address,
	      chain
	    });
	  }
	  async decrypt({
	    walletId,
	    data,
	    address,
	    chain
	  }) {
	    return await this.getResult(walletId, 'decrypt', {
	      data,
	      address,
	      chain
	    });
	  }
	  async isConnected({
	    walletId = null
	  } = {}) {
	    if (!walletId) walletId = this.walletId;
	    if (!walletId) return false;
	    const span = Date.now() - this.lastChecking;
	    if (span > 1000 * 5) {
	      this.lastChecking = Date.now();
	      const res = await this.nbpeer.send(walletId, "ping");
	      this.connected = res === 'pong';
	    }
	    return this.connected;
	  }
	  async getResult(walletId, ...args) {
	    const func = args[0];
	    const para = args.slice(1);
	    const request = {
	      name: func,
	      para
	    };
	    if (!walletId) walletId = this.walletId;
	    //if (walletId === 'vbox') {
	    //    return await window.VBox.getResult(func, ...para)
	    //}
	    const res = await this.nbpeer.send(walletId, "session_request", request);
	    return res;
	  }
	  on(eventName, cb) {
	    this.eventCB[eventName] = cb;
	  }
	  onElse(cb) {
	    this.eventCB['_any'] = cb;
	  }
	  async _fire(name, ...args) {
	    const cb = this.eventCB[name];
	    const cb1 = this.eventCB['_any'];
	    return cb ? await cb(...args) : cb1 ? await cb1(name, ...args) : null;
	  }
	  async disconnect() {
	    this.nbpeer.disconnect();
	    this.id = null;
	  }
	  async optionsToUrl(options) {
	    const saveURL = "/api/relay/save";
	    const getURL = "/api/relay/get/";
	    const res = await fetch(this.nbNode + saveURL, {
	      method: "post",
	      headers: {
	        Accept: "application/json, text/plain, */*",
	        "Content-Type": "application/json"
	      },
	      body: JSON.stringify(options)
	    });
	    return res.ok ? getURL + options.id : null;
	  }
	  async createSession() {
	    if (!this.nbpeer.isConnected()) {
	      const res = await this.nbpeer.create({
	        id: this.id,
	        nbNode: this.nbNode,
	        debug: this.debug
	      });
	      return res;
	    }
	    return {
	      code: 0
	    };
	  }
	  notify(walletId, ...argv) {
	    if (!walletId) walletId = this.walletId;
	    if (walletId === 'vbox') {
	      window.VBox.notify(...argv);
	    }
	    this.nbpeer.send(walletId, 'notify', ...argv);
	  }
	}

	return WalletApp;

}));
