/* Version: 1.0.4 - October 9, 2022 16:33:52 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.WalletApp = factory());
})(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var qrmodal_min = {exports: {}};

	/* Version: 1.0.2 - October 9, 2022 16:33:47 */

	(function (module, exports) {
	(function (global, factory) {
	  module.exports = factory() ;
	})(commonjsGlobal, function () {

	  class Util {
	    static async loadScript(url) {
	      return new Promise(resolve => {
	        var script = document.createElement("script");
	        script.type = "text/javascript";

	        script.onload = function () {
	          resolve(true);
	        };

	        script.onerror = () => {
	          console.error("error loading" + url);
	          resolve(false);
	        };

	        script.src = url;
	        document.getElementsByTagName("head")[0].appendChild(script);
	      });
	    }

	  }

	  const payPopupHtml = `
<style scoped>
._opay_pageOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0.5;
  background: #000;
  z-index: 1000;
}

#_opay_payPopup {
  display:flex;
  position:absolute;
  align-items: center;
  left: 50%; 
  top: 50%; 
  transform: translate(-50%, -50%);
  width: 30rem;
  z-index: 1100;
}
._opay_closeButton {
    margin: 5px;
    cursor: pointer;
    float: right;
  }

._qrcode{
  box-shadow: 0 4px 12px 0 rgb(37 41 46 / 25%);
  width:300px;
  height:300px;
  margin:20px auto;
  display:block;
}
._wallet{
  width:140px;
  height:180px;
  margin:50px auto;
}
._wallet ._icon{
  margin:5px 3px;
  width:96px;
  height:96px;
  box-shadow: 0 4px 12px 0 rgb(37 41 46 / 25%);
}
._subTitle{
  color: rgba(60, 66, 82, 0.6);
    font-size: 16px;
    font-weight: 600;
    letter-spacing: 0;
    line-height: 1.1875em;
    margin: 10px 0 20px 0;
    text-align: center;
    width: 100%;
}
._tabs {
  width: 100%;
  text-align:center;
  background-color: white;
  border-radius: 0.5rem;
  box-shadow: 0 5px 10px rgba(0, 0, 0, 0.25);
}

._tab-control {
  display: inline-block;
  text-align:center;
  border-bottom: 2px solid transparent;
  font-size: 1.25rem;
  padding: 0.6rem 2rem;
  cursor: pointer;
  transition: all 0.25s ease;
}

._tab-control:hover {
  color: #ed1e79;
}

._tab-content {
  border-top: 1px solid #ed1e79;
  padding: 1rem;
}

._tab-panel {
  display: none;
  height:400px;
}

/* Magic style */
input[type="radio"]:checked + ._tab-control {
  font-weight: 600;
  color: #ed1e79;
  border-bottom-color: #ed1e79;
}

#_tab-1:checked ~ ._tab-content > #_tab-panel-1 {
  display: block;
}

#_tab-2:checked ~ ._tab-content > #_tab-panel-2 {
  display: block;
}
</style>
<div id="_opay_payPopup">

  <div class="_tabs">
    <div class="_opay_closeButton">
        ✖
      </div>
    <input hidden type="radio" name="tab-css" id="_tab-1" checked />
    <label class="_tab-control" for="_tab-1" tid="qrPay">QR Code</label>
    <input hidden type="radio" name="tab-css" id="_tab-2" />
    <label class="_tab-control" for="_tab-2" tid="desktop">Desktop</label>
  
    <div class="_tab-content">
      <div id="_tab-panel-1" class="_tab-panel">
        <div class="_subTitle" tid="title_qr_panel">Scan QR code with an dwebPay compatible wallet 
        </div>
        <img id="_opay_qrcode" class="_qrcode"></img>
        <a href="#" id="_copy_clipboard" tid="_copy_clipboard">Copy to Clipboard</a>
      </div>
      <div id="_tab-panel-2" class="_tab-panel">
        <div class="_subTitle" tid="title_desktop_panel">
          Choose your prefered Wallet
        </div>
        <div class="_wallet">
        <img id="_vboxWallet" src="$scriptPath$vbox-icon.png" class="_icon"/><p>VBox</p></div>
      </div>
      
    </div>
  </div>
</div>
`;
	  const scriptPath = document && document.currentScript.src;

	  class qrModal {
	    constructor(bridge) {
	      this.nbNode = bridge;
	    }

	    async show(uri, callback) {
	      const self = this;
	      this.abortController = new AbortController();
	      let emPopup = document.querySelector("#_opay_payPopup");

	      if (!emPopup) {
	        let src = scriptPath;
	        src = src.slice(0, src.lastIndexOf('/') + 1);
	        const html = payPopupHtml.replace("$scriptPath$", src);
	        emPopup = document.createElement('div');
	        emPopup.innerHTML = html;
	        document.body.appendChild(emPopup);
	        emPopup = document.querySelector("#_opay_payPopup");
	      } else {
	        emPopup.style.display = 'flex';
	      }

	      let emOverlay = document.querySelector("._opay_pageOverlay");
	      if (!emOverlay) document.querySelector("body").insertAdjacentHTML('beforeend', '<div class="_opay_pageOverlay"></div>');else {
	        emOverlay.style.display = 'block';
	      }
	      self.translate("_opay_payPopup");
	      await self.genQRImg(uri, "_opay_qrcode"); //vbox button

	      this.onEvent('click', "#_vboxWallet", () => {
	        callback("clickWallet", "vbox");
	      }); // Close button

	      this.onEvent('click', "._opay_closeButton", () => {
	        console.log('click close');
	        this.closePopup();
	        callback("closed");
	      });
	      this.onEvent('click', "#_copy_clipboard", () => {
	        navigator.clipboard.writeText(uri).then(() => {
	          alert('Copied');
	        });
	      });
	      this.callback = callback;
	    }

	    onEvent(eventType, selector, callback) {
	      const elm = document.querySelector(selector);

	      if (elm) {
	        elm.addEventListener(eventType, callback, {
	          signal: this.abortController.signal
	        });
	      }
	    }

	    closePopup() {
	      document.querySelector('#_opay_payPopup').style.display = 'none'; // hide

	      document.querySelector('._opay_pageOverlay').style.display = 'none'; // hide

	      if (this.callback) {
	        this.abortController.abort();
	      }
	    }

	    close() {
	      this.closePopup();
	    }

	    translate(parentID) {
	      if (navigator.language.toLowerCase() != "zh-cn") return;
	      var cntext = {
	        webPay: "网页",
	        qrPay: "扫码支付",
	        desktop: "桌面",
	        vbox: "傲游 VBox",
	        dot: "打点钱包",
	        title: "点击钱包或扫码",
	        vinstall: "未检测到，点击安装",
	        login: "登录",
	        next: "下一步",
	        title_qr_panel: "请使用 dwebPay 兼容钱包扫描",
	        title_desktop_panel: "请点击钱包",
	        _copy_clipboard: "复制到剪贴板"
	      };
	      var items = document.getElementById(parentID).querySelectorAll("[tid]");

	      for (let i = 0; i < items.length; i++) {
	        const item = items[i];
	        const tid = item.attributes['tid'].value;
	        item.innerText = cntext[tid];
	      }
	    }

	    async genQRImg(uri, imgID, checker = true) {
	      if (!window.qrcode) {
	        await Util.loadScript("https://cdnjs.cloudflare.com/ajax/libs/qrcode-generator/1.4.4/qrcode.min.js");
	      }

	      const strQR = uri;
	      var typeNumber = 0;
	      var errorCorrectionLevel = "L";
	      var qr = qrcode(typeNumber, errorCorrectionLevel);
	      qr.addData(strQR);
	      qr.make();
	      let strImgTag = qr.createDataURL(4);
	      document.getElementById(imgID).src = strImgTag;
	    }

	  }

	  return qrModal;
	});
	}(qrmodal_min));

	var qrModal = qrmodal_min.exports;

	var nbpeer_min = {exports: {}};

	/* Version: 1.0.22 - September 23, 2022 15:44:05 */

	(function (module, exports) {
	(function (global, factory) {
	  module.exports = factory() ;
	})(commonjsGlobal, function () {

	  var isBrowser = isBrowser || new Function('try {return this===window;}catch(e){ return false;}');
	  isBrowser();

	  const str2Array = strData => Uint8Array.from(Array.from(strData).map(letter => letter.charCodeAt(0)));

	  const fromHexString = hexString => Uint8Array.from(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));

	  function decodeEnc(encObj) {
	    encObj.iv = eccryptoJS.arrayToBuffer(encObj.iv.data);
	    encObj.mac = eccryptoJS.arrayToBuffer(encObj.mac.data);
	    encObj.ciphertext = eccryptoJS.arrayToBuffer(encObj.ciphertext.data);
	    encObj.ephemPublicKey = eccryptoJS.arrayToBuffer(encObj.ephemPublicKey.data);
	  }

	  async function loadScript(url) {
	    return new Promise(resolve => {
	      var script = document.createElement('script');
	      script.type = 'text/javascript';

	      script.onload = function () {
	        resolve(true);
	      };

	      script.onerror = () => {
	        console.error('error loading' + url);
	        resolve(false);
	      };

	      script.src = url;
	      document.getElementsByTagName('head')[0].appendChild(script);
	    });
	  }

	  let log = console.log;

	  class nbpeer {
	    constructor() {
	      this.eventCB = {};
	      console.log('nbpeer: 1.0.22 - September 23, 2022 15:44:05');
	    }

	    async init() {
	      if (!this.inited) {
	        if (!window.io) {
	          await loadScript('https://cdn.socket.io/4.5.0/socket.io.min.js');
	        }

	        if (!window.eccryptoJS) {
	          await loadScript('https://unpkg.com/eccrypto-js@5.4.0/dist/umd/index.min.js');
	          this.keypair = eccryptoJS.generateKeyPair();
	        }

	        this.inited = true;
	      }
	    }

	    async create(info) {
	      await this.init();

	      if (!info.debug) {
	        log = msg => {};
	      }

	      const self = this;
	      return new Promise(resolve => {
	        //const socket = io(info.node,{autoConnect:false});
	        const manager = new io.Manager(info.node, {
	          autoConnect: false
	        });
	        delete info.node;

	        if (!info.id) {
	          info.id = Date.now().toString(36);
	        }

	        const socket = manager.socket("/nbpeer");
	        socket.auth = {
	          info
	        };
	        manager.open(err => {
	          if (err) {
	            return {
	              code: 0,
	              msg: err
	            };
	          }
	        });
	        socket.connect();
	        socket.on('connect', () => {
	          log('connected socket:', socket.id); // x8WIv7-mJelg7on_ALbx

	          self.id = info.id;
	          self.socket = socket;
	          resolve({
	            code: 0,
	            msg: "success",
	            id: self.id
	          });
	        });
	        socket.onAny(async (event, ...args) => {
	          log('nbpeer:got event:', event, ...args);
	          const encrypted = JSON.parse(args[0]);
	          decodeEnc(encrypted);
	          const deMsg = await eccryptoJS.decrypt(this.keypair.privateKey, encrypted);
	          const argv = JSON.parse(deMsg.toString());

	          self._fire(event, ...argv, args[1]);
	        });
	      });
	    }

	    getKey() {
	      return eccryptoJS.getPublicCompressed(this.keypair.privateKey).toString('hex');
	    }

	    setEncryptKey(enKey) {
	      this.enKey = eccryptoJS.decompress(fromHexString(enKey));
	    }

	    async _fire(name, ...args) {
	      const cb = this.eventCB[name];
	      const cb1 = this.eventCB['_any'];
	      const ret = cb ? await cb(...args) : cb1 ? await cb1(name, ...args) : null;
	      const retFn = args[args.length - 1];

	      if (typeof retFn == 'function') {
	        retFn(ret);
	      }

	      return ret;
	    }

	    on(name, cb) {
	      if (!this.eventCB) this.eventCB = {};
	      this.eventCB[name] = cb;
	    }

	    onElse(cb) {
	      this.eventCB['_any'] = cb;
	    }

	    offAll() {
	      this.eventCB = {};
	    }

	    isConnected() {
	      return this.socket && this.socket.connected;
	    }

	    async disconnect() {
	      this.socket && this.socket.disconnect();
	      this.socket = null;

	      this._fire('disconnected');
	    }

	    async send(des_id, event, ...args) {
	      return new Promise(resolve => {
	        console.log("send event:", event, des_id, ...args);
	        let strArgs = JSON.stringify(args);

	        if (this.enKey) {
	          strArgs = JSON.stringify(eccryptoJS.encryptSync(this.enKey, str2Array(strArgs)));
	        }

	        this.socket.emit(event, des_id, strArgs, res => {
	          resolve(res);
	        });
	      });
	    }

	  }

	  return nbpeer;
	});
	}(nbpeer_min));

	var nbpeer = nbpeer_min.exports;

	var isBrowser = isBrowser || new Function('try {return this===window;}catch(e){ return false;}');
	const g_isBrowser = isBrowser();
	class WalletApp {
	  async init({
	    appid,
	    bridge,
	    debug
	  }) {
	    this.appid = appid;
	    this.nbNode = bridge;
	    this.debug = debug;
	    this.eventCB = {};
	    this.id = Date.now().toString(36);
	    this.nbpeer = new nbpeer();
	    await this.nbpeer.init();
	    this.modal = new qrModal({
	      bridge
	    });
	    this.nbpeer.on('session_event', event => {
	      if (event.name === 'approved') {
	        this.desid = event.para.wallet_id;
	        this.nbpeer.setEncryptKey(event.para.key);
	        console.log('got wallet id:', this.desid);
	        this.modal.close();
	      }

	      this._fire('session_event', event);
	    });
	    this.nbpeer.onElse((eName, ...args) => {
	      console.log("got nbpeer event:", eName, ...args);

	      this._fire(eName, ...args);
	    });
	  }

	  async connect({
	    permissions
	  }) {
	    const options = {
	      id: this.id,
	      appid: this.appid,
	      permissions
	    };
	    let res = await this.createSession();

	    if (res.code == 0) {
	      if (this.desid) {
	        res = await this.getResult('connectWallet', options);
	        console.log(res);
	      }

	      if (res.code != 0 || !this.desid) {
	        const url = await this.optionsToUrl(options);
	        const uri = `wp:${this.id}?node=${encodeURIComponent(this.nbNode)}&key=${this.nbpeer.getKey()}&path=${encodeURIComponent(url)}`;
	        console.log(uri);
	        this.modal.show(uri, async (event, para) => {
	          console.log("event from modal:", event, para);

	          if (event === 'click') {
	            if (para === 'vbox') {
	              vbox.connect(options);
	            }
	          }
	        });
	      }
	    }

	    return {
	      code: 0
	    };
	  }

	  async getBalance(address, chain) {
	    return await this.getResult('getBalance', address, chain);
	  }
	  /**
	   * 
	   * @param {*} option:
	   * {    
	   *      data:['abc',123] //optional
	   *      to:[address:'fafasf',value:100] //optional
	   *      chain:chain //required
	   * } 
	   * @returns (json)
	   * {
	   *      code:0 //successful
	   *      msg:"successful" //error message or success
	   * }
	   */


	  async sendTransaction(option) {
	    return await this.getResult('sendTransaction', option);
	  }
	  /**
	   * 
	   * @param {*} option :
	   * {
	   *  signer:(string)address
	   *  message:(string)msg
	   *  chain:(string)chain
	   * }
	   * @returns (json)
	   * {
	   *      code:0 //successful
	   *      msg:"successful" //(string) error message or success
	   *      sig:"" //(string) signature
	   * }
	   */


	  async signMessage(option) {
	    return await this.getResult('signMessage', option);
	  }

	  async getResult(...args) {
	    const func = args[0];
	    const para = args.slice(1);
	    const request = {
	      name: func,
	      para
	    };

	    if (this.desid === 'vbox') {
	      return await vbox.invoke(func, ...para);
	    }

	    const res = await this.nbpeer.send(this.desid, "session_request", request);
	    return res;
	  }

	  on(eventName, cb) {
	    this.eventCB[eventName] = cb;
	  }

	  onElse(cb) {
	    this.eventCB['_any'] = cb;
	  }

	  async _fire(name, ...args) {
	    const cb = this.eventCB[name];
	    const cb1 = this.eventCB['_any'];
	    return cb ? await cb(...args) : cb1 ? await cb1(name, ...args) : null;
	  }

	  async disconnect() {
	    this.nbpeer.disconnect();
	    this.id = null;
	  }

	  async optionsToUrl(options) {
	    const saveURL = "/api/relay/save";
	    const getURL = "/api/relay/get/";
	    const res = await fetch(this.nbNode + saveURL, {
	      method: "post",
	      headers: {
	        Accept: "application/json, text/plain, */*",
	        "Content-Type": "application/json"
	      },
	      body: JSON.stringify(options)
	    });
	    return res.ok ? getURL + options.id : null;
	  }

	  async createSession() {
	    if (!this.relaySocket) {
	      await this.updateNode();
	    }

	    if (!this.relaySocket) return {
	      code: 1,
	      msg: "invalid or offline nbNode"
	    };

	    if (!this.nbpeer.isConnected()) {
	      const res = await this.nbpeer.create({
	        id: this.id,
	        node: this.relaySocket,
	        debug: this.debug
	      });
	      return res;
	    }

	    return {
	      code: 0
	    };
	  }

	  notify(...argv) {
	    if (this.desid === 'vbox') {
	      vbox.notify(...argv);
	    }

	    this.desid && this.nbpeer.send(this.desid, 'notify', ...argv);
	  }

	  async updateNode(nbNode) {
	    if (!nbNode) nbNode = this.nbNode;
	    let res = await fetch(nbNode + "/api/nodeinfo");

	    if (res.ok) {
	      const info = await res.json();
	      const pUrl = g_isBrowser ? new URL(nbNode) : URL.parse(url);
	      this.relaySocket = "ws://" + pUrl.hostname + ":" + (info.socketPort || 31415);

	      if (info.socketServer) {
	        relaySocket = "ws://" + info.socketServer + ":" + (info.socketPort || 31415);
	      }

	      this.nbNode = nbNode;
	      return true;
	    }

	    return false;
	  }

	}

	return WalletApp;

}));
