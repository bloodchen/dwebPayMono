/* Version: 1.0.8 - October 22, 2022 13:07:18 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.WalletApp = factory());
})(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var qrmodal_min = {exports: {}};

	/* Version: 1.0.2 - October 18, 2022 10:02:27 */

	(function (module, exports) {
	(function (global, factory) {
	  module.exports = factory() ;
	})(commonjsGlobal, function () {

	  class Util {
	    static async loadScript(url) {
	      return new Promise(resolve => {
	        var script = document.createElement("script");
	        script.type = "text/javascript";
	        script.onload = function () {
	          resolve(true);
	        };
	        script.onerror = () => {
	          console.error("error loading" + url);
	          resolve(false);
	        };
	        script.src = url;
	        document.getElementsByTagName("head")[0].appendChild(script);
	      });
	    }
	  }
	  const payPopupHtml = `
<style scoped>
._opay_pageOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0.5;
  background: #000;
  z-index: 1000;
}

#_opay_payPopup {
  display:flex;
  position:absolute;
  align-items: center;
  left: 50%; 
  top: 50%; 
  transform: translate(-50%, -50%);
  width: 30rem;
  z-index: 1100;
}
._opay_closeButton {
    margin: 5px;
    cursor: pointer;
    float: right;
  }

._qrcode{
  box-shadow: 0 4px 12px 0 rgb(37 41 46 / 25%);
  width:300px;
  height:300px;
  margin:20px auto;
  display:block;
}
._wallet{
  width:140px;
  height:180px;
  margin:50px auto;
}
._wallet ._icon{
  margin:5px 3px;
  width:96px;
  height:96px;
  box-shadow: 0 4px 12px 0 rgb(37 41 46 / 25%);
}
._subTitle{
  color: rgba(60, 66, 82, 0.6);
    font-size: 16px;
    font-weight: 600;
    letter-spacing: 0;
    line-height: 1.1875em;
    margin: 10px 0 20px 0;
    text-align: center;
    width: 100%;
}
._tabs {
  width: 100%;
  text-align:center;
  background-color: white;
  border-radius: 0.5rem;
  box-shadow: 0 5px 10px rgba(0, 0, 0, 0.25);
}

._tab-control {
  display: inline-block;
  text-align:center;
  border-bottom: 2px solid transparent;
  font-size: 1.25rem;
  padding: 0.6rem 2rem;
  cursor: pointer;
  transition: all 0.25s ease;
}

._tab-control:hover {
  color: #ed1e79;
}

._tab-content {
  border-top: 1px solid #ed1e79;
  padding: 1rem;
}

._tab-panel {
  display: none;
  height:400px;
}

/* Magic style */
input[type="radio"]:checked + ._tab-control {
  font-weight: 600;
  color: #ed1e79;
  border-bottom-color: #ed1e79;
}

#_tab-1:checked ~ ._tab-content > #_tab-panel-1 {
  display: block;
}

#_tab-2:checked ~ ._tab-content > #_tab-panel-2 {
  display: block;
}
</style>
<div id="_opay_payPopup">

  <div class="_tabs">
    <div class="_opay_closeButton">
        ✖
      </div>
    <input hidden type="radio" name="tab-css" id="_tab-1" checked />
    <label class="_tab-control" for="_tab-1" tid="qrPay">QR Code</label>
    <input hidden type="radio" name="tab-css" id="_tab-2" />
    <label class="_tab-control" for="_tab-2" tid="desktop">Desktop</label>
  
    <div class="_tab-content">
      <div id="_tab-panel-1" class="_tab-panel">
        <p id="_debug" style="color:red;">DEBUG (not for production)</p>
        <div class="_subTitle" tid="title_qr_panel">Scan QR code with an dwebPay compatible wallet 
        </div>
        <img id="_opay_qrcode" class="_qrcode"></img>
        <a href="#" id="_copy_clipboard" tid="_copy_clipboard">Copy to Clipboard</a><span id='_check_success' style="display:none;">✌</span>
      </div>
      <div id="_tab-panel-2" class="_tab-panel">
        <div class="_subTitle" tid="title_desktop_panel">
          Choose your prefered Wallet
        </div>
        <div class="_wallet">
        <img id="_vboxWallet" src="$scriptPath$vbox-icon.png" class="_icon"/><p>VBox</p></div>
      </div>
      
    </div>
  </div>
</div>
`;
	  const scriptPath = document && document.currentScript.src;
	  class qrModal {
	    constructor({
	      bridge,
	      debug
	    }) {
	      this.nbNode = bridge;
	      this.debug = debug;
	    }
	    async show(uri, callback) {
	      const self = this;
	      this.abortController = new AbortController();
	      let emPopup = document.querySelector("#_opay_payPopup");
	      if (!emPopup) {
	        let src = scriptPath;
	        src = src.slice(0, src.lastIndexOf('/') + 1);
	        const html = payPopupHtml.replace("$scriptPath$", src);
	        emPopup = document.createElement('div');
	        emPopup.innerHTML = html;
	        document.body.appendChild(emPopup);
	        emPopup = document.querySelector("#_opay_payPopup");
	      } else {
	        emPopup.style.display = 'flex';
	      }
	      let emOverlay = document.querySelector("._opay_pageOverlay");
	      if (!emOverlay) document.querySelector("body").insertAdjacentHTML('beforeend', '<div class="_opay_pageOverlay"></div>');else {
	        emOverlay.style.display = 'block';
	      }
	      self.translate("_opay_payPopup");
	      await self.genQRImg(uri, "_opay_qrcode");
	      if (!self.debug) {
	        document.querySelector("#_debug").style.display = 'none';
	      } //vbox button

	      this.onEvent('click', "#_vboxWallet", () => {
	        callback("clickWallet", "vbox");
	      }); // Close button

	      this.onEvent('click', "._opay_closeButton", () => {
	        console.log('click close');
	        this.closePopup();
	        callback("closed");
	      });
	      this.onEvent('click', "#_copy_clipboard", () => {
	        navigator.clipboard.writeText(uri).then(() => {
	          document.querySelector('#_check_success').style.display = 'inline';
	          setTimeout(() => {
	            document.querySelector('#_check_success').style.display = 'none';
	          }, 3000);
	        });
	      });
	      this.callback = callback;
	    }
	    onEvent(eventType, selector, callback) {
	      const elm = document.querySelector(selector);
	      if (elm) {
	        elm.addEventListener(eventType, callback, {
	          signal: this.abortController.signal
	        });
	      }
	    }
	    closePopup() {
	      document.querySelector('#_opay_payPopup').style.display = 'none'; // hide

	      document.querySelector('._opay_pageOverlay').style.display = 'none'; // hide

	      if (this.callback) {
	        this.abortController.abort();
	      }
	    }
	    close() {
	      this.closePopup();
	    }
	    translate(parentID) {
	      if (navigator.language.toLowerCase() != "zh-cn") return;
	      var cntext = {
	        webPay: "网页",
	        qrPay: "扫码支付",
	        desktop: "桌面",
	        vbox: "傲游 VBox",
	        dot: "打点钱包",
	        title: "点击钱包或扫码",
	        vinstall: "未检测到，点击安装",
	        login: "登录",
	        next: "下一步",
	        title_qr_panel: "请使用 dwebPay 兼容钱包扫描",
	        title_desktop_panel: "请点击钱包",
	        _copy_clipboard: "复制到剪贴板"
	      };
	      var items = document.getElementById(parentID).querySelectorAll("[tid]");
	      for (let i = 0; i < items.length; i++) {
	        const item = items[i];
	        const tid = item.attributes['tid'].value;
	        item.innerText = cntext[tid];
	      }
	    }
	    async genQRImg(uri, imgID, checker = true) {
	      if (!window.qrcode) {
	        await Util.loadScript("https://cdnjs.cloudflare.com/ajax/libs/qrcode-generator/1.4.4/qrcode.min.js");
	      }
	      const strQR = uri;
	      var typeNumber = 0;
	      var errorCorrectionLevel = "L";
	      var qr = qrcode(typeNumber, errorCorrectionLevel);
	      qr.addData(strQR);
	      qr.make();
	      let strImgTag = qr.createDataURL(4);
	      document.getElementById(imgID).src = strImgTag;
	    }
	  }
	  return qrModal;
	});
	}(qrmodal_min));

	var qrModal = qrmodal_min.exports;

	var nbpeer_min = {exports: {}};

	/* Version: 1.0.31 - October 18, 2022 14:45:09 */

	(function (module, exports) {
	(function (global, factory) {
	  module.exports = factory() ;
	})(commonjsGlobal, function () {

	  var isBrowser = isBrowser || new Function('try {return this===window;}catch(e){ return false;}');
	  var io, eccryptoJS, fetch;
	  const g_isBrowser = isBrowser();
	  const str2Array = strData => Uint8Array.from(Array.from(strData).map(letter => letter.charCodeAt(0)));
	  const fromHexString = hexString => Uint8Array.from(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
	  function decodeEnc(encObj) {
	    encObj.iv = eccryptoJS.arrayToBuffer(encObj.iv.data);
	    encObj.mac = eccryptoJS.arrayToBuffer(encObj.mac.data);
	    encObj.ciphertext = eccryptoJS.arrayToBuffer(encObj.ciphertext.data);
	    encObj.ephemPublicKey = eccryptoJS.arrayToBuffer(encObj.ephemPublicKey.data);
	  }
	  async function loadScript(url) {
	    return new Promise(resolve => {
	      var script = document.createElement('script');
	      script.type = 'text/javascript';
	      script.onload = function () {
	        resolve(true);
	      };
	      script.onerror = () => {
	        console.error('error loading' + url);
	        resolve(false);
	      };
	      script.src = url;
	      document.getElementsByTagName('head')[0].appendChild(script);
	    });
	  }
	  let log = console.log;
	  class nbpeer {
	    constructor() {
	      this.eventCB = {};
	      this.enKeys = {};
	      console.log('nbpeer: 1.0.31 - October 18, 2022 14:45:09');
	    }
	    async init() {
	      if (!this.inited) {
	        if (g_isBrowser) {
	          if (!window.io) {
	            await loadScript('https://cdn.socket.io/4.5.0/socket.io.min.js');
	            io = window.io;
	          }
	          if (!window.eccryptoJS) {
	            await loadScript('https://unpkg.com/eccrypto-js@5.4.0/dist/umd/index.min.js');
	            eccryptoJS = window.eccryptoJS;
	          }
	          fetch = window.fetch;
	        } else {
	          io = require("socket.io-client").io;
	          eccryptoJS = require("eccrypto-js");
	          fetch = require('cross-fetch');
	        }
	        this.inited = true;
	      }
	    }
	    getId() {
	      return this.id;
	    }
	    async getSocketUrl(nbNode) {
	      let res = await fetch(nbNode + "/api/nodeinfo");
	      if (res.ok) {
	        const info = await res.json();
	        const pUrl = new URL(nbNode);
	        let relaySocket = "ws://" + pUrl.hostname + ":" + (info.socketPort || 31415);
	        if (info.socketServer) {
	          relaySocket = "ws://" + info.socketServer + ":" + (info.socketPort || 31415);
	        }
	        return relaySocket;
	      }
	      return null;
	    }
	    async create(info) {
	      await this.init();
	      if (!info.debug) {
	        log = msg => {};
	      }
	      this.keypair = eccryptoJS.generateKeyPair();
	      let socketUrl = info.socketUrl;
	      if (!socketUrl) {
	        socketUrl = await this.getSocketUrl(info.nbNode);
	      }
	      if (!socketUrl) {
	        throw "Need socketUrl or nbNode";
	      }
	      const self = this;
	      return new Promise(resolve => {
	        const manager = new io.Manager(socketUrl, {
	          autoConnect: false
	        });
	        delete info.node;
	        if (!info.id) {
	          info.id = Date.now().toString(36);
	        }
	        self.id = info.id;
	        const socket = manager.socket("/nbpeer");
	        socket.auth = {
	          info
	        };
	        manager.open(err => {
	          if (err) {
	            return {
	              code: 0,
	              msg: err
	            };
	          }
	        });
	        socket.connect();
	        socket.on('connect', () => {
	          log('connected socket:', socket.id); // x8WIv7-mJelg7on_ALbx

	          self.id = info.id;
	          self.socket = socket;
	          resolve({
	            code: 0,
	            msg: "success",
	            id: self.id
	          });
	        });
	        socket.on('exchangeKey', (from_id, args, ret) => {
	          const key = JSON.parse(args)[0];
	          self.setEncryptKey(key, from_id);
	          ret(self.getKey());
	        });
	        socket.onAny(async (event, ...args) => {
	          log('nbpeer:got event:', event, ...args);
	          if (event === 'exchangeKey') return;
	          const from_id = args[0];
	          const encrypted = JSON.parse(args[1]);
	          decodeEnc(encrypted);
	          const deMsg = await eccryptoJS.decrypt(this.keypair.privateKey, encrypted);
	          const argv = JSON.parse(deMsg.toString());
	          self._fire(event, from_id, ...argv, args[2]);
	        });
	      });
	    }
	    async connectTo(desid) {
	      const key = await this.send(desid, 'exchangeKey', this.getKey());
	      this.setEncryptKey(key, desid);
	    }
	    getKey() {
	      return eccryptoJS.getPublicCompressed(this.keypair.privateKey).toString('hex');
	    }
	    setEncryptKey(enKey, desid) {
	      this.enKeys[desid] = eccryptoJS.decompress(fromHexString(enKey));
	    }
	    async _fire(name, ...args) {
	      const cb = this.eventCB[name];
	      const cb1 = this.eventCB['_any'];
	      const ret = cb ? await cb(...args) : cb1 ? await cb1(name, ...args) : null;
	      const retFn = args[args.length - 1];
	      if (typeof retFn == 'function') {
	        retFn(ret);
	      }
	      return ret;
	    }
	    on(name, cb) {
	      if (!this.eventCB) this.eventCB = {};
	      this.eventCB[name] = cb;
	    }
	    onElse(cb) {
	      this.eventCB['_any'] = cb;
	    }
	    offAll() {
	      this.eventCB = {};
	    }
	    isConnected() {
	      return this.socket && this.socket.connected;
	    }
	    async disconnect() {
	      this.socket && this.socket.disconnect();
	      this.socket = null;
	      this._fire('disconnected');
	    }
	    async send(des_id, event, ...args) {
	      return new Promise(resolve => {
	        log("send event:", event, des_id, ...args);
	        let strArgs = JSON.stringify(args);
	        if (this.enKeys[des_id]) {
	          strArgs = JSON.stringify(eccryptoJS.encryptSync(this.enKeys[des_id], str2Array(strArgs)));
	        }
	        this.socket.emit(event, des_id, this.id, strArgs, res => {
	          resolve(res);
	        });
	      });
	    }
	  }
	  return nbpeer;
	});
	}(nbpeer_min));

	var nbpeer = nbpeer_min.exports;

	var isBrowser = isBrowser || new Function('try {return this===window;}catch(e){ return false;}');
	isBrowser();
	class WalletApp {
	  async init({
	    appid,
	    bridge,
	    debug = true
	  }) {
	    this.appid = appid;
	    this.nbNode = bridge;
	    this.debug = debug;
	    this.eventCB = {};
	    this.id = Date.now().toString(36);
	    const res = await fetch(bridge + "/api/q/" + appid);
	    if (res.ok) {
	      this.meta = await res.json();
	    } else {
	      console.error("can't fetch:", appid);
	      return false;
	    }
	    this.nbpeer = new nbpeer();
	    await this.nbpeer.init();
	    this.modal = new qrModal({
	      bridge,
	      debug
	    });
	    this.nbpeer.on('session_notify', (wallet_id, event) => {
	      if (event.name === 'approved') {
	        //this.nbpeer.setEncryptKey(event.para.key)
	        console.log('got wallet id:', wallet_id);
	        this.modal.close();
	      }
	      this._fire('session_notify', wallet_id, event);
	    });
	    this.nbpeer.onElse((eName, ...args) => {
	      console.log("got nbpeer event:", eName, ...args);
	      this._fire(eName, ...args);
	    });
	    return true;
	  }
	  async connect(walletId, {
	    permissions
	  }) {
	    const options = {
	      id: this.id,
	      appid: this.appid,
	      permissions
	    };
	    let res = await this.createSession();
	    if (res.code == 0) {
	      if (res.code != 0 || !walletId) {
	        const url = await this.optionsToUrl(options);
	        const uri = `wp:${this.id}?node=${encodeURIComponent(this.nbNode)}&key=${this.nbpeer.getKey()}&path=${encodeURIComponent(url)}`;
	        console.log(uri);
	        this.modal.show(uri, async (event, para) => {
	          console.log("event from modal:", event, para);
	          if (event === 'click') {
	            if (para === 'vbox') {
	              if (!window.VBox) {
	                alert('VBox is not found');
	                return;
	              }
	              window.VBox.connect(uri);
	              return {
	                code: 0
	              };
	            }
	          }
	        });
	      }
	    }
	    return {
	      code: 0
	    };
	  }
	  async getBalance(walletId, address, chain) {
	    return await this.getResult(walletId, 'getBalance', address, chain);
	  }
	  async getPubKey(walletId, address, chain) {
	    return await this.getResult(walletId, 'getPubKey', address, chain);
	  }
	  async signTransaction(walletId, option) {
	    return await this.getResult(walletId, 'signTransaction', option);
	  }
	  async sendTransaction(walletId, option) {
	    return await this.getResult(walletId, 'sendTransaction', option);
	  }
	  async getAddresses(walletId, chain) {
	    return await this.getResult(walletId, 'getAddresses', chain);
	  }
	  async getAccounts(walletId, chain) {
	    return await this.getResult(walletId, 'getAccounts', chain);
	  }
	  async signMessage(walletId, strData, chain) {
	    return await this.getResult(walletId, 'signMessage', strData, chain);
	  }
	  async decrypt(walletId, data, chain) {
	    return await this.getResult(walletId, 'decrypt', data, chain);
	  }
	  async getResult(walletId, ...args) {
	    const func = args[0];
	    const para = args.slice(1);
	    const request = {
	      name: func,
	      para
	    };
	    if (walletId === 'vbox') {
	      return await window.VBox.getResult(func, ...para);
	    }
	    const res = await this.nbpeer.send(walletId, "session_request", request);
	    return res;
	  }
	  on(eventName, cb) {
	    this.eventCB[eventName] = cb;
	  }
	  onElse(cb) {
	    this.eventCB['_any'] = cb;
	  }
	  async _fire(name, ...args) {
	    const cb = this.eventCB[name];
	    const cb1 = this.eventCB['_any'];
	    return cb ? await cb(...args) : cb1 ? await cb1(name, ...args) : null;
	  }
	  async disconnect() {
	    this.nbpeer.disconnect();
	    this.id = null;
	  }
	  async optionsToUrl(options) {
	    const saveURL = "/api/relay/save";
	    const getURL = "/api/relay/get/";
	    const res = await fetch(this.nbNode + saveURL, {
	      method: "post",
	      headers: {
	        Accept: "application/json, text/plain, */*",
	        "Content-Type": "application/json"
	      },
	      body: JSON.stringify(options)
	    });
	    return res.ok ? getURL + options.id : null;
	  }
	  async createSession() {
	    if (!this.nbpeer.isConnected()) {
	      const res = await this.nbpeer.create({
	        id: this.id,
	        nbNode: this.nbNode,
	        debug: this.debug
	      });
	      return res;
	    }
	    return {
	      code: 0
	    };
	  }
	  notify(walletId, ...argv) {
	    if (walletId === 'vbox') {
	      window.VBox.notify(...argv);
	    }
	    this.nbpeer.send(walletId, 'notify', ...argv);
	  }
	}

	return WalletApp;

}));
